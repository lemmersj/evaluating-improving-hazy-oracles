"""Calculates the DEV metric for a method."""
import os
import pickle
import numpy as np
import matplotlib.pyplot as plt

plt.rc('axes',titlesize=24)
plt.rc('axes',labelsize=22)
plt.rc('xtick',labelsize=18)
plt.rc('ytick',labelsize=18)
plt.rc('legend',fontsize=18)

# Get all of the stochastic runs generated by perform_runs.py
files = os.listdir("better_smear")

run_dict = {}

# For every stochastic run
for this_file in files:
    # Figure out what method this is
    method = this_file.split("-")[0]

    # and open the pickle.
    with open(f"better_smear/{this_file}", "rb") as infile:
        data = pickle.load(infile)
        # If there's no data, skip the file and tell the user.
        if data[:, -1, :].sum() == 0:
            print(f"skipping {this_file}")
            continue

    # update the array containing errors.
    # each method has a key in run_dict
    if method not in run_dict:
        run_dict[method] = data
    else:
        run_dict[method] = run_dict[method]+data

# Make the marginal plot
fig, (ax1, ax2) = plt.subplots(1, 2)
x = np.array([*range(101)])/101
for method in run_dict:
    method_label = method
    if "consensus" in method:
        color = "#FFB000"
    elif "naive" in method:
        color = "#FE6100"
    elif "smart" in method:
        color = "#DC267F"
    elif "combined" in method:
        color = "#785EF0"
    elif "mean" in method:
        color = "#648FFF"
        method_label = "Mean"
    where_not_zero = np.where(run_dict[method].sum(axis=0).sum(axis=0) != 0)[0]
    where_zero = np.where(run_dict[method].sum(axis=0).sum(axis=0) == 0)[0]

    # Notify and skip any unpopulated runs
    print(f"method {method} zero for runs {where_zero}")

    # Calculate the DEV metric
    method_where_not_zero = run_dict[method][:, :, where_not_zero]
    au_metric = method_where_not_zero.mean(axis=0).mean(axis=0)
    au_stderr = au_metric.std()/np.sqrt(len(au_metric))
    au_metric = au_metric.mean()

    # and the acc @ 1
    acc_1 = method_where_not_zero[:, -1, :].mean()
    acc_1_stderr = method_where_not_zero[:, -1, :].std()/np.sqrt(len(where_not_zero))
    # print results
    print(f"{method}-AU: {au_metric}+-{au_stderr}. Acc1: {acc_1}+-{acc_1_stderr}")

    # Now calc and plot the marginals
    rqr_marginal = method_where_not_zero.mean(axis=0)
    rqr_marginal_stderr = rqr_marginal.std(axis=1)/np.sqrt(
        rqr_marginal.shape[1])
    rqr_marginal = rqr_marginal.mean(axis=1)

    ax2.plot(x, rqr_marginal, label=method_label, color=color)
    ax2.fill_between(x, rqr_marginal-rqr_marginal_stderr,
                     rqr_marginal+rqr_marginal_stderr, alpha=0.5, color=color)

    rqd_marginal = method_where_not_zero.mean(axis=1)
    rqd_marginal_stderr = rqd_marginal.std(axis=1)/np.sqrt(
        rqd_marginal.shape[1])
    rqd_marginal = rqd_marginal.mean(axis=1)

    ax1.plot([*range(1, 11)], rqd_marginal, label=method_label,
             color=color, marker='o')
    ax1.fill_between([*range(1, 11)], rqd_marginal-rqd_marginal_stderr,
                     rqd_marginal+rqd_marginal_stderr, alpha=0.5, color=color)

ax1.set_xticks([*range(1,11)])
ax1_ylim = ax1.get_ylim()
ax2_ylim = ax2.get_ylim()
ylim_min = min(ax1_ylim[0], ax2_ylim[0])
ylim_max = max(ax1_ylim[1], ax2_ylim[1])

ax1.set_ylim([ylim_min, ylim_max])
ax2.set_ylim([ylim_min, ylim_max])

ax2.axes.yaxis.set_visible(False)
ax1.set_xlabel("Depth Constraint")
ax1.set_ylabel("Mean Error")
ax2.set_xlabel("Re-Query Rate")
ax2.legend(loc=(1.1, 0.5))
fig.set_size_inches(20, 6)
plt.tight_layout()
plt.savefig("marginals.pdf")
